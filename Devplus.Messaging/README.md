# Devplus.Messaging üì¨

[![NuGet](https://img.shields.io/nuget/v/Devplus.Messaging.svg)](https://www.nuget.org/packages/Devplus.Messaging/)
[![Downloads](https://img.shields.io/nuget/dt/Devplus.Messaging.svg)](https://www.nuget.org/packages/Devplus.Messaging/)

**Devplus.Messaging** √© uma biblioteca .NET para integra√ß√£o avan√ßada com RabbitMQ, oferecendo funcionalidades completas de publica√ß√£o e consumo de mensagens baseadas no padr√£o **CloudEvents**, com suporte a Dead Letter Queue (DLQ), retry autom√°tico, m√∫ltiplos tipos de fila e configura√ß√µes flex√≠veis.

## ‚ú® **Caracter√≠sticas**

- üì¨ **Publica√ß√£o e consumo de mensagens** baseado no padr√£o **CloudEvents**
- üîÑ **Sistema de retry autom√°tico** com configura√ß√£o personaliz√°vel
- üíÄ **Dead Letter Queue (DLQ)** autom√°tica para mensagens falhas
- üèóÔ∏è **Suporte a filas Quorum e Classic** do RabbitMQ
- ‚öôÔ∏è **Configura√ß√£o flex√≠vel** via appsettings.json
- üöÄ **Hosted Service integrado** para gerenciamento autom√°tico de consumidores
- üìä **QoS (Quality of Service)** configur√°vel por consumidor
- üîó **Binding autom√°tico** de exchanges e filas
- üõ°Ô∏è **Tratamento robusto de erros** e reconex√£o autom√°tica
- üìù **Logging detalhado** para monitoramento e debug

---

## üöÄ Instala√ß√£o

Para instalar a biblioteca via **NuGet**, utilize o seguinte comando:

```sh
dotnet add package Devplus.Messaging
```

Ou, no **Visual Studio**:

1. Abra o **Gerenciador de Pacotes NuGet**.
2. Busque por **Devplus.Messaging**.
3. Clique em **Instalar**.

---

## ‚ö° **Como Usar**

### üì¶ **Publicando Mensagens**

O `IMessagingPublisher` permite publicar mensagens seguindo o padr√£o CloudEvents:

```csharp
using Devplus.Messaging.Interfaces;

public class ProdutoService
{
    private readonly IMessagingPublisher _messagingPublisher;

    public ProdutoService(IMessagingPublisher messagingPublisher)
    {
        _messagingPublisher = messagingPublisher;
    }

    public async Task CriarProduto(Produto produto)
    {
        // Salvar produto no banco...

        // Publicar evento
        await _messagingPublisher.PublishAsync(
            exchangeName: "produtos-exchange",
            message: new {
                ProdutoId = produto.Id,
                Nome = produto.Nome,
                Preco = produto.Preco
            },
            source: "produtos.api",
            typeEvent: "produto.criado",
            messageId: Guid.NewGuid().ToString(), // Opcional
            routingKey: "produtos.criados" // Opcional
        );
    }
}
```

#### Par√¢metros do `PublishAsync`:

| Par√¢metro      | Tipo     | Obrigat√≥rio | Descri√ß√£o                                                      |
| -------------- | -------- | ----------- | -------------------------------------------------------------- |
| `exchangeName` | `string` | ‚úÖ Sim      | Nome do exchange RabbitMQ                                      |
| `message`      | `T`      | ‚úÖ Sim      | Objeto da mensagem a ser publicada                             |
| `source`       | `string` | ‚úÖ Sim      | Origem da mensagem (ex: "api.produtos")                        |
| `typeEvent`    | `string` | ‚úÖ Sim      | Tipo do evento (ex: "produto.criado")                          |
| `messageId`    | `string` | ‚ùå N√£o      | ID √∫nico da mensagem (gerado automaticamente se n√£o informado) |
| `routingKey`   | `string` | ‚ùå N√£o      | Chave de roteamento (padr√£o: vazio)                            |

### üì© **Consumindo Mensagens**

Para consumir mensagens, implemente a interface `IMessagingConsumer`:

```csharp
using Devplus.Messaging.Interfaces;
using Devplus.Messaging.Models;
using Devplus.Messaging.Enum;

public class ProdutoCriadoConsumer : IMessagingConsumer
{
    // ‚úÖ Obrigat√≥rio
    public string ExchangeName => "produtos-exchange";

    // ‚öôÔ∏è Configura√ß√µes opcionais (valores padr√£o mostrados)
    public string QueueName => "produtos-criados-queue";
    public string RoutingKey => "produtos.criados";
    public int MaxRetry => 5;
    public ushort PrefetchCount => 3;
    public QueueType QueueType => QueueType.Quorum;

    private readonly ILogger<ProdutoCriadoConsumer> _logger;
    private readonly IEmailService _emailService;

    public ProdutoCriadoConsumer(
        ILogger<ProdutoCriadoConsumer> logger,
        IEmailService emailService)
    {
        _logger = logger;
        _emailService = emailService;
    }

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Processando produto criado: {Data}", cloudEvent.Data);

        try
        {
            // Processar a mensagem
            var produto = JsonSerializer.Deserialize<ProdutoDto>(cloudEvent.Data.ToString());

            // Enviar email de notifica√ß√£o
            await _emailService.EnviarNotificacao($"Novo produto: {produto.Nome}");

            _logger.LogInformation("Produto {ProdutoId} processado com sucesso", produto.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erro ao processar produto criado");
            throw; // Ser√° reenviado automaticamente at√© MaxRetry
        }
    }
}
```

### ‚öôÔ∏è **Propriedades do IMessagingConsumer**

| Propriedade       | Obrigat√≥rio | Padr√£o                                | Descri√ß√£o                                            |
| ----------------- | ----------- | ------------------------------------- | ---------------------------------------------------- |
| **ExchangeName**  | ‚úÖ **Sim**  | N/A                                   | Nome do exchange RabbitMQ para binding               |
| **QueueName**     | ‚ùå N√£o      | `"{ExchangeName-sem-exchange}-queue"` | Nome da fila personalizada                           |
| **RoutingKey**    | ‚ùå N√£o      | `""`                                  | Chave de roteamento para binding espec√≠fico          |
| **MaxRetry**      | ‚ùå N√£o      | `5`                                   | N√∫mero m√°ximo de tentativas antes de enviar para DLQ |
| **PrefetchCount** | ‚ùå N√£o      | `3`                                   | M√°ximo de mensagens simult√¢neas sem ACK (QoS)        |
| **QueueType**     | ‚ùå N√£o      | `QueueType.Quorum`                    | Tipo de fila: `Quorum` ou `Classic`                  |

#### üìã **Exemplos de Nomes Autom√°ticos**:

```csharp
// ExchangeName: "produtos-exchange" ‚Üí QueueName: "produtos-queue"
// ExchangeName: "pedidos.exchange" ‚Üí QueueName: "pedidos-queue"
// ExchangeName: "eventos-sistema" ‚Üí QueueName: "eventos-sistema-queue"
```

### üîÑ **Sistema de Retry e Recupera√ß√£o**

```csharp
public class ProcessadorPedidos : IMessagingConsumer
{
    public string ExchangeName => "pedidos-exchange";
    public int MaxRetry => 3; // Tentar at√© 3 vezes antes de enviar para DLQ

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        try
        {
            // Processar pedido...
            await ProcessarPedido(cloudEvent.Data);
        }
        catch (HttpRequestException ex)
        {
            // Erro tempor√°rio - ser√° reprocessado automaticamente
            _logger.LogWarning("Falha tempor√°ria: {Error}", ex.Message);
            throw;
        }
        catch (ArgumentException ex)
        {
            // Erro permanente - registrar e n√£o relan√ßar (vai para ACK)
            _logger.LogError("Dados inv√°lidos: {Error}", ex.Message);
            // N√£o faz throw - mensagem ser√° confirmada (ACK)
        }
    }
}
```

## ÔøΩ **DLQ (Dead Letter Queue)**

A **Dead Letter Queue (DLQ)** √© uma funcionalidade autom√°tica para lidar com mensagens que falharam ap√≥s m√∫ltiplas tentativas.

### üèóÔ∏è **Configura√ß√£o Autom√°tica**

A biblioteca cria automaticamente:

```csharp
// Exchange principal: "produtos-exchange"
// Exchange DLX:      "produtos-exchange-dlx"
// Fila principal:    "produtos-queue"
// Fila DLQ:          "produtos-queue-dlq"
```

### üìä **Headers Autom√°ticos na DLQ**

Quando uma mensagem √© enviada para DLQ, os seguintes headers s√£o adicionados:

```csharp
{
    "x-retry-count": "5",                           // Total de tentativas
    "x-last-process": "2025-09-28T10:30:00.000Z",   // √öltima tentativa
    "x-send-dlq": "2025-09-28T10:30:05.000Z"        // Timestamp do envio para DLQ
}
```

### üîç **Monitoramento de DLQ**

```csharp
public class DlqMonitorService
{
    public async Task ProcessarDlq()
    {
        // Processar mensagens na DLQ manualmente
        // ou configurar alertas para DLQ com muitas mensagens
    }
}
```

### ‚ö†Ô∏è **Cen√°rios de Envio para DLQ**

- ‚úÖ **Exception n√£o tratada** ap√≥s MaxRetry tentativas
- ‚úÖ **Timeout de processamento** recorrente
- ‚úÖ **Falhas de conex√£o** com APIs externas
- ‚ùå **Erro de dados inv√°lidos** (deve ser tratado sem throw)

## üìã **Modelos e Interfaces**

### üåê **CloudEvent&lt;T&gt; (Padr√£o CloudEvents)**

```csharp
public class CloudEvent<T>
{
    [JsonPropertyName("specversion")]
    public string SpecVersion { get; set; } = "1.0";

    [JsonPropertyName("type")]
    public string Type { get; set; }              // Tipo do evento

    [JsonPropertyName("source")]
    public string Source { get; set; }            // Origem da mensagem

    [JsonPropertyName("id")]
    public string Id { get; set; }                // ID √∫nico da mensagem

    [JsonPropertyName("time")]
    public DateTimeOffset Time { get; set; }      // Timestamp do evento

    [JsonPropertyName("datacontenttype")]
    public string DataContentType { get; set; } = "application/json";

    [JsonPropertyName("data")]
    public T Data { get; set; }                   // Payload da mensagem
}
```

### üîå **IMessagingPublisher**

```csharp
public interface IMessagingPublisher
{
    /// <summary>
    /// Publica uma mensagem no exchange especificado
    /// </summary>
    Task PublishAsync<T>(
        string exchangeName,    // Exchange de destino
        T message,             // Dados da mensagem
        string typeEvent,      // Tipo do evento (ex: "pedido.criado")
        string source,         // Origem (ex: "api.pedidos")
        string messageId = "", // ID √∫nico (auto-gerado se vazio)
        string routingKey = "" // Chave de roteamento (opcional)
    );
}
```

### üì• **IMessagingConsumer**

```csharp
public interface IMessagingConsumer
{
    // ‚úÖ Obrigat√≥rias
    string ExchangeName { get; }
    Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken);

    // ‚öôÔ∏è Opcionais (com valores padr√£o)
    string QueueName => /* gerado automaticamente */;
    string RoutingKey => "";
    int MaxRetry => 5;
    ushort PrefetchCount => 3;
    QueueType QueueType => QueueType.Quorum;
}
```

### üèóÔ∏è **Tipos de Fila (QueueType)**

```csharp
public enum QueueType
{
    Quorum,  // ‚úÖ Recomendado - Alta disponibilidade e durabilidade
    Classic  // ‚ö†Ô∏è  Tradicional - Para compatibilidade com vers√µes antigas
}
```

## üîß **Configura√ß√£o**

### ‚öôÔ∏è **appsettings.json**

```json
{
  "RabbitMq": {
    "Host": "localhost", // Endere√ßo do servidor RabbitMQ
    "Port": 5672, // Porta de conex√£o (padr√£o: 5672)
    "Username": "admin", // Usu√°rio de autentica√ß√£o
    "Password": "senha123", // Senha de autentica√ß√£o
    "VHost": "/", // Virtual Host (padr√£o: "/")
    "GlobalPrefetchCount": 10, // QoS global (padr√£o: 3)
    "UseGlobalPrefetch": true // Usar QoS global (padr√£o: true)
  }
}
```

### üöÄ **Configura√ß√£o no Program.cs**

```csharp
using Devplus.Messaging;

var builder = WebApplication.CreateBuilder(args);

// ‚úÖ Registrar a biblioteca Messaging
builder.Services.AddMessaging(builder.Configuration);

// ‚úÖ Registrar seus consumidores
builder.Services.AddScoped<IMessagingConsumer, ProdutoCriadoConsumer>();
builder.Services.AddScoped<IMessagingConsumer, PedidoCanceladoConsumer>();
builder.Services.AddScoped<IMessagingConsumer, EmailEnviadoConsumer>();

// ‚úÖ Registrar outros servi√ßos
builder.Services.AddScoped<IProdutoService, ProdutoService>();
builder.Services.AddScoped<IEmailService, EmailService>();

var app = builder.Build();

// O RabbitMqHostedService ser√° iniciado automaticamente
app.Run();
```

### üìä **Configura√ß√µes Avan√ßadas de RabbitMQ**

```json
{
  "RabbitMq": {
    "Host": "rabbitmq-cluster.empresa.com",
    "Port": 5672,
    "Username": "app-user",
    "Password": "senha-super-segura",
    "VHost": "/producao",
    "GlobalPrefetchCount": 50, // Para alto throughput
    "UseGlobalPrefetch": false // QoS por consumidor individual
  }
}
```

## üß™ **Exemplo Completo de Implementa√ß√£o**

### üì¶ **Servi√ßo de Publica√ß√£o**

```csharp
public class PedidoService
{
    private readonly IMessagingPublisher _publisher;
    private readonly IPedidoRepository _repository;

    public PedidoService(IMessagingPublisher publisher, IPedidoRepository repository)
    {
        _publisher = publisher;
        _repository = repository;
    }

    public async Task CriarPedido(CriarPedidoDto dto)
    {
        // 1. Salvar no banco
        var pedido = new Pedido(dto.ClienteId, dto.Produtos);
        await _repository.SalvarAsync(pedido);

        // 2. Publicar eventos
        await _publisher.PublishAsync(
            exchangeName: "pedidos-exchange",
            message: new PedidoCriadoEvent
            {
                PedidoId = pedido.Id,
                ClienteId = pedido.ClienteId,
                ValorTotal = pedido.ValorTotal,
                DataCriacao = pedido.DataCriacao
            },
            source: "api.pedidos",
            typeEvent: "pedido.criado",
            routingKey: "pedidos.criados"
        );

        // 3. Evento para estoque
        await _publisher.PublishAsync(
            exchangeName: "estoque-exchange",
            message: new { PedidoId = pedido.Id, Produtos = pedido.Produtos },
            source: "api.pedidos",
            typeEvent: "estoque.reserva-solicitada",
            routingKey: "estoque.reservas"
        );
    }
}
```

### üì• **M√∫ltiplos Consumidores**

```csharp
// ‚úÖ Consumidor para notifica√ß√µes por email
public class NotificacaoEmailConsumer : IMessagingConsumer
{
    public string ExchangeName => "pedidos-exchange";
    public string QueueName => "notificacoes-email-queue";
    public string RoutingKey => "pedidos.criados";

    private readonly IEmailService _emailService;

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        var pedido = JsonSerializer.Deserialize<PedidoCriadoEvent>(cloudEvent.Data.ToString());
        await _emailService.EnviarConfirmacao(pedido.ClienteId, pedido.PedidoId);
    }
}

// ‚úÖ Consumidor para integra√ß√£o com ERP
public class IntegracaoErpConsumer : IMessagingConsumer
{
    public string ExchangeName => "pedidos-exchange";
    public string QueueName => "integracao-erp-queue";
    public string RoutingKey => "pedidos.criados";
    public int MaxRetry => 10; // ERP pode estar inst√°vel

    private readonly IErpService _erpService;

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        var pedido = JsonSerializer.Deserialize<PedidoCriadoEvent>(cloudEvent.Data.ToString());
        await _erpService.SincronizarPedido(pedido);
    }
}

// ‚úÖ Consumidor para reserva de estoque
public class ReservaEstoqueConsumer : IMessagingConsumer
{
    public string ExchangeName => "estoque-exchange";
    public string QueueName => "reservas-estoque-queue";
    public string RoutingKey => "estoque.reservas";
    public QueueType QueueType => QueueType.Quorum; // Alta disponibilidade

    private readonly IEstoqueService _estoqueService;

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        var reserva = JsonSerializer.Deserialize<ReservaEstoqueEvent>(cloudEvent.Data.ToString());
        await _estoqueService.ReservarProdutos(reserva.PedidoId, reserva.Produtos);
    }
}
```

## ‚ö° **Funcionalidades T√©cnicas**

### üèóÔ∏è **Arquitetura da Biblioteca**

```
Devplus.Messaging/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ Configuration/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RabbitMqConfig.cs           # Configura√ß√µes RabbitMQ
‚îÇ   ‚îú‚îÄ‚îÄ Enum/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ QueueType.cs                # Tipos de fila (Quorum/Classic)
‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IMessagingConsumer.cs       # Interface para consumidores
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IMessagingPublisher.cs      # Interface para publica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CloudEvent.cs               # Modelo CloudEvents
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RabbitMqHostedService.cs    # Background service para consumidores
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RabbitMqPublisher.cs        # Implementa√ß√£o do publisher
‚îÇ   ‚îî‚îÄ‚îÄ MessagingServiceCollectionExtensions.cs # DI configuration
```

### üîó **Recursos Autom√°ticos**

| Recurso                  | Descri√ß√£o                                          |
| ------------------------ | -------------------------------------------------- |
| **Exchange Declaration** | Cria√ß√£o autom√°tica de exchanges do tipo `topic`    |
| **Queue Declaration**    | Cria√ß√£o autom√°tica de filas (principais e DLQ)     |
| **Binding Automation**   | Vincula√ß√£o autom√°tica entre exchanges e filas      |
| **DLX Setup**            | Configura√ß√£o autom√°tica de Dead Letter Exchange    |
| **Reconnection**         | Reconex√£o autom√°tica em caso de falhas             |
| **QoS Management**       | Gerenciamento de Quality of Service por consumidor |

### üìä **M√©tricas e Monitoramento**

```csharp
// Logs autom√°ticos gerados pela biblioteca
[INFO] Message publish - Exchange: produtos-exchange, RoutingKey: produtos.criados, MessageId: abc123
[INFO] Message received Queue: produtos-queue Consumer: ProdutoCriadoConsumer
[WARN] Erro ao processar mensagem da fila produtos-queue - Retry 2/5
[ERROR] Mensagem enviada para DLQ ap√≥s 5 tentativas - Queue: produtos-queue-dlq
[WARN] Canal do consumidor ProdutoCriadoConsumer foi encerrado. Reason: Connection lost
[INFO] Consumidor ProdutoCriadoConsumer reconectado com sucesso
```

### ÔøΩÔ∏è **Tratamento de Erros e Resili√™ncia**

```csharp
public class ProcessadorPagamentos : IMessagingConsumer
{
    public string ExchangeName => "pagamentos-exchange";
    public int MaxRetry => 3;

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        try
        {
            await ProcessarPagamento(cloudEvent.Data);
        }
        catch (PaymentGatewayException ex) when (ex.IsRetryable)
        {
            // ‚úÖ Erro tempor√°rio - ser√° reprocessado
            _logger.LogWarning("Falha tempor√°ria no gateway: {Error}", ex.Message);
            throw; // Reprocessar
        }
        catch (InvalidCardException ex)
        {
            // ‚ùå Erro permanente - n√£o reprocessar
            _logger.LogError("Cart√£o inv√°lido: {Error}", ex.Message);
            await _notificationService.NotificarCartaoInvalido(ex.CardId);
            // N√£o faz throw - vai para ACK
        }
        catch (Exception ex)
        {
            // ‚ö†Ô∏è Erro desconhecido - reprocessar
            _logger.LogError(ex, "Erro inesperado no processamento");
            throw;
        }
    }
}
```

### üîß **Configura√ß√µes de Performance**

```json
{
  "RabbitMq": {
    "Host": "localhost",
    "Port": 5672,
    "Username": "user",
    "Password": "pass",
    "VHost": "/",
    "GlobalPrefetchCount": 100, // Alto throughput
    "UseGlobalPrefetch": false // QoS individual por consumidor
  }
}
```

```csharp
// Consumidor otimizado para alta performance
public class HighVolumeConsumer : IMessagingConsumer
{
    public string ExchangeName => "eventos-volume-exchange";
    public ushort PrefetchCount => 50;           // Processar at√© 50 mensagens simult√¢neas
    public QueueType QueueType => QueueType.Quorum; // Alta disponibilidade
    public int MaxRetry => 2;                    // Retry r√°pido

    public async Task ConsumeAsync(CloudEvent<object> cloudEvent, CancellationToken cancellationToken)
    {
        // Processamento otimizado e r√°pido
        await ProcessarRapidamente(cloudEvent.Data);
    }
}
```

## üõ†Ô∏è **Compatibilidade e Versioning**

| .NET Version   | Suportado          | RabbitMQ Client |
| -------------- | ------------------ | --------------- |
| .NET 8.0       | ‚úÖ **Recomendado** | 6.8.x           |
| .NET 7.0       | ‚úÖ Sim             | 6.8.x           |
| .NET 6.0       | ‚úÖ Sim             | 6.8.x           |
| .NET Core 3.1  | ‚ö†Ô∏è Limitado        | 6.x             |
| .NET Framework | ‚ùå N√£o             | -               |

### üìà **Versionamento Sem√¢ntico**

- **Major (X.y.z)**: Mudan√ßas incompat√≠veis na API
- **Minor (x.Y.z)**: Novas funcionalidades compat√≠veis
- **Patch (x.y.Z)**: Corre√ß√µes de bugs

## üöÄ **Docker e Desenvolvimento**

### üê≥ **RabbitMQ com Docker Compose**

A biblioteca inclui um `docker-compose.yaml` para desenvolvimento local:

```yaml
# docker/docker-compose.yaml
version: "3.8"
services:
  rabbitmq:
    image: rabbitmq:3.13-management
    container_name: devplus-rabbitmq
    ports:
      - "5672:5672" # AMQP port
      - "15672:15672" # Management UI
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin123
      RABBITMQ_DEFAULT_VHOST: /
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

volumes:
  rabbitmq_data:
```

**Comandos √∫teis**:

```bash
# Iniciar RabbitMQ
docker-compose -f docker/docker-compose.yaml up -d

# Acessar Management UI
open http://localhost:15672
# Usu√°rio: admin, Senha: admin123

# Parar RabbitMQ
docker-compose -f docker/docker-compose.yaml down
```

## üèóÔ∏è **Melhores Pr√°ticas**

### ‚úÖ **Recomenda√ß√µes**

1. **üìù Nomea√ß√£o Consistente**: Use padr√µes como `{dominio}-{acao}-exchange`
2. **üîÑ Retry Inteligente**: Configure `MaxRetry` baseado no tipo de opera√ß√£o
3. **üìä QoS Adequado**: Ajuste `PrefetchCount` conforme capacidade de processamento
4. **üèóÔ∏è Filas Quorum**: Use `QueueType.Quorum` para alta disponibilidade
5. **üîç Logs Detalhados**: Implemente logging estruturado nos consumidores
6. **‚ö†Ô∏è Tratamento de Erros**: Diferencie erros tempor√°rios de permanentes
7. **üéØ Routing Keys**: Use routing keys para roteamento espec√≠fico

### ‚ùå **Evite**

- ‚ùå Processar mensagens grandes (>1MB) - use refer√™ncias
- ‚ùå Opera√ß√µes s√≠ncronas longas nos consumidores
- ‚ùå Fazer throw para erros de dados inv√°lidos
- ‚ùå Usar `PrefetchCount` muito alto sem CPU/mem√≥ria adequada
- ‚ùå Ignorar mensagens na DLQ sem monitoramento

### üîß **Exemplo de Configura√ß√£o de Produ√ß√£o**

```json
{
  "RabbitMq": {
    "Host": "rabbitmq-cluster.prod.empresa.com",
    "Port": 5672,
    "Username": "${RABBITMQ_USER}",
    "Password": "${RABBITMQ_PASSWORD}",
    "VHost": "/producao",
    "GlobalPrefetchCount": 20,
    "UseGlobalPrefetch": false
  }
}
```

## üìÑ **Licen√ßa**

Este projeto est√° licenciado sob a [MIT License](../LICENSE).

---

## üìû **Suporte**

Para d√∫vidas, sugest√µes ou problemas:

üìß **Email**: [clayton@devplus.com.br](mailto:clayton@devplus.com.br)  
üîó **LinkedIn**: [Clayton Oliveira](https://www.linkedin.com/in/clayton-oliveira-7929b121/)  
üöÄ **Website**: [www.devplus.com.br](https://www.devplus.com.br)

### ü§ù **Contribui√ß√µes**

Contribui√ß√µes s√£o bem-vindas! Para contribuir:

1. üç¥ **Fork** o reposit√≥rio
2. üåø **Crie uma branch**: `git checkout -b feature/nova-funcionalidade`
3. üíª **Implemente** sua funcionalidade com testes
4. üìù **Commit**: `git commit -m "feat: adicionar nova funcionalidade"`
5. üì§ **Push**: `git push origin feature/nova-funcionalidade`
6. üîÑ **Abra um Pull Request** com descri√ß√£o detalhada

---

**Devplus.Messaging v2.7.4** - Mensageria robusta e escal√°vel para aplica√ß√µes .NET üöÄ
